diff --git a/src/bufwrite.c b/src/bufwrite.c
index 23cd884bf..05adc9d5a 100644
--- a/src/bufwrite.c
+++ b/src/bufwrite.c
@@ -1857,7 +1857,6 @@ buf_write(
 			}
 		    }
 		}
-
 restore_backup:
 		{
 		    stat_T	st;
@@ -1898,6 +1897,21 @@ restore_backup:
 		    vim_free(wfname);
 		goto fail;
 	    }
+
+#ifdef __MVS__
+      if (newfile == TRUE)
+        __tag_new_file(fd);
+      else if (st_old.st_tag.ft_ccsid == FT_UNTAGGED) {
+        __setfdccsid(fd, 0);
+        struct f_cnvrt cvtreq = {SETCVTON, 0, 1047};
+        if (curbuf->needs_conversion)
+          fcntl(fd, F_CONTROL_CVT, &cvtreq);
+        __setfdccsid(fd, 0);
+      }
+      else
+        __chgfdccsid(fd, st_old.st_tag.ft_ccsid);
+#endif
+
 	    write_info.bw_fd = fd;
 
 #if defined(UNIX)
@@ -2516,6 +2530,44 @@ restore_backup:
 	    && mch_remove(backup) != 0)
 	emsg(_(e_cant_delete_backup_file));
 
+#ifdef __MVS__
+  if (buf->is_dataset && write_bin) {
+    msg_puts_attr(_("\nATTENTION: Writing binary datasets it not supported.\n"),
+                  attr | MSG_HIST);
+  } else if (buf->is_dataset) {
+    // copy from temporary file back to dataset
+    struct DFILE *dsfile = open_dataset(buf->dsname, NULL);
+    if (!dsfile) {
+      errmsg = (char_u *)_("Libdio failed to allocate");
+      buffer = NULL;
+      goto fail;
+    }
+
+    if (dsfile->err) {
+      errmsg = dsfile->msgbuff;
+      close_dataset(dsfile);
+      goto fail;
+    }
+
+    if (read_temp_file_to_buffer(fname, dsfile) == NULL) {
+      errmsg = dsfile->msgbuff;
+      close_dataset(dsfile);
+      goto fail;
+    } 
+
+    if (write_dataset(dsfile)) {
+      errmsg = dsfile->msgbuff;
+      close_dataset(dsfile);
+      goto fail;
+    }
+
+    if (close_dataset(dsfile)) {
+      errmsg = dsfile->msgbuff;
+      goto fail;
+    }
+  }
+#endif
+
     goto nofail;
 
     // Finish up.  We get here either after failure or success.
